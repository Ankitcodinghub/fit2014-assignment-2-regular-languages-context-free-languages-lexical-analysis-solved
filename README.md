# fit2014-assignment-2-regular-languages-context-free-languages-lexical-analysis-solved
**TO GET THIS SOLUTION VISIT:** [FIT2014 Assignment 2-Regular Languages, Context-Free Languages, Lexical analysis Solved](https://www.ankitcodinghub.com/product/fit2014-faculty-of-information-technology-solved-2/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;110030&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;2&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (2 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;FIT2014  Assignment 2-Regular Languages, Context-Free Languages, Lexical analysis Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (2 votes)    </div>
    </div>
Regular Languages, Context-Free Languages, Lexical analysis, Parsing,

Turing machines and Quaternions

In these exercises, you will

‚Ä¢ implement a lexical analyser using lex (Problems 2, 4);

‚Ä¢ implement parsers using lex and yacc (Problems 1, 3‚Äì6);

‚Ä¢ program a Turing machine (Problem 7);

‚Ä¢ learn about quaternions, by applying our methods to calculations with them (Problems 3‚Äì6);

‚Ä¢ practise your skills relating to context-free languages (Problem 8).

Solutions to Problem 7 must be implemented in the simulator Tuatara. We are providing version 2.1 on Moodle under week 8; the file name is tuatara-monash-2.1.jar. You must use exactly this version, not some other version downloaded from the internet. Do not unpack this file. It must be run directly using the Java runtime.

How to manage this assignment

For Problem 1‚Äì5, read the background material on pp. 7‚Äì11.

For Problems 2‚Äì6, also read the background material on pp. 12‚Äì14. For Problems 7‚Äì8, read the background material on p. 15.

Instructions

Instructions are as for Assignment 1, except that some of the filenames have changed. To begin working on the assignment, download the workbench asgn2.zip from Moodle. Create a new Ed Workspace and upload this file, letting Ed automatically extract it. Edit the student-id file to contain your name and student ID. Refer to Lab 0 for a reminder on how to do these tasks.

Open a terminal and change into the directory asgn2. You will find three files already in the directory: plus-times-power.l, plus-times-power.y, and quat.h. You will not modify these files directly; you will make copies of the first two and modify the copies, while quat.h must remain unaltered in the directory where you do this work.

You need to construct new lex files, using plus-times-power.l as a starting point, for Problems 1, 4 &amp; 5, and you‚Äôll need to construct a new yacc file from plus-times-power.y for Problem 5. Your submission must include:

‚Ä¢ a lex file prob1.l which should be obtained by modifying a copy of plus-times-power.l

‚Ä¢ a text file prob2.txt which should contain a single line with a regular expression in lex syntax ‚Ä¢ a PDF file prob3.pdf which should contain your solution to Problem 3

‚Ä¢ a lex file prob4.l which should also be obtained by modifying a copy of plus-times-power.l

‚Ä¢ a lex file prob5.l which should be obtained by modifying a copy of prob4.l

‚Ä¢ a yacc file prob5.y which should be obtained by modifying a copy of plus-times-power.y

‚Ä¢ a text file prob6.txt which should contain two lines, being your solution to Problem 6

‚Ä¢ a Tuatara Turing machine file prob7.tm

‚Ä¢ a PDF file prob8.pdf which should contain your solution to Problem 8.

Each of the problem directories under the asgn2 directory contains empty files with the required filenames. These must each be replaced by the files you write, as described above. Before submission, check that each of these empty files is, indeed, replaced by your own file.

Assignment tasks

For each problem, the files you are submitting must be in the corresponding subdirectory, i.e. problemx for Problem x.

First, read about ‚ÄúLex, Yacc and the PLUS-TIMES-POWER language‚Äù on pp. 7‚Äì11.

Construct prob1.l, as described on pp. 9‚Äì11, so that it can be used with plus-times-power.y to build a parser for PLUS-TIMES-POWER.

Now refer to the document ‚ÄúQuaternions and the language QUAT‚Äù, pages 12‚Äì14.

Write a regular expression, using the regular expression syntax used by lex, that matches any finite decimal representation (of the type specified on p. 12) of a nonnegative real number. Save it as a file prob2.txt.txt

Write a Context-Free Grammar for the language QUAT over the fifteen-symbol alphabet {i, j, k, +, -, *, /, ^, |, (, ), NUMBER,WHOLENUMBER, ROTATION, , }. It can be typed or hand-written, but must be in PDF format and saved as a file prob3.pdf.pdf.

Now we use regular expressions (in the lex file, prob4.l) and a grammar (in the yacc file, prob5.y) to construct a lexical analyser (Problem 4) and a parser (Problem 5) for QUAT.

Using the file provided for PLUS-TIMES-POWER as a starting point, construct a lex file, prob4.l, and use it to build a lexical analyser for QUAT.

You‚Äôll need to change the regular expressions associated with the NUMBER, WHOLENUMBER and some other tokens, among other things.

Sample output: $./a.out

Rotation(120.0,2.0i+2.0j+2.0k)^2 * i / Rotation(120.0,2.0i+2.0j+2.0k)^2

Token: ROTATION; Lexeme: Rotation

Token and Lexeme: (

Token: NUMBER; Lexeme: 120.0

Token and Lexeme: ,

Token: NUMBER; Lexeme: 2.0

Token and Lexeme: i

Token and Lexeme: +

Token: NUMBER; Lexeme: 2.0

Token and Lexeme: j

Token and Lexeme: +

Token: NUMBER; Lexeme: 2.0

Token and Lexeme: k

Token and Lexeme: )

Token and Lexeme: ^

Token: WHOLENUMBER; Lexeme: 2

Token and Lexeme: *

Token and Lexeme: i

Token and Lexeme: /

Token: ROTATION; Lexeme: Rotation

Token and Lexeme: (

Token: NUMBER; Lexeme: 120.0

Token and Lexeme: ,

Token: NUMBER; Lexeme: 2.0

Token and Lexeme: i

Token and Lexeme: +

Token: NUMBER; Lexeme: 2.0

Token and Lexeme: j

Token and Lexeme: +

Token: NUMBER; Lexeme: 2.0

Token and Lexeme: k

Token and Lexeme: )

Token and Lexeme: ^

Token: WHOLENUMBER; Lexeme: 2

Token and Lexeme: &lt;newline&gt;

Control-D

Make a copy of prob4.l, call it prob5.l, then modify it so that it can be used with yacc. Then construct a yacc file prob5.y from plus-times-power.y. Then use these lex and yacc files to build a parser for QUAT.

Note that you do not have to program any of the quaternion functions yourself. They have already been written: see the Programs section of the yacc file. The actions in your yacc file will need to call these functions, and you can do that by using the function call for pow(‚Ä¶) in plus-times-power.y as a template.

The core of your task is to write the grammar rules in the Rules section, in yacc format, with associated actions, using the examples in plus-times-power.y as a guide. You also need to do some modifications in the Declarations section; see page 10 and further details below.

When entering your grammar into the Rules section of prob5.y, it is best to leave the existing rules for the nonterminal start unchanged, as this has some extra stuff designed to allow you to enter a series of separate expressions on separate lines. So, take the Start symbol from your grammar in Problem 2 and represent it by the nonterminal line instead of by start.

The specific modifications you need to do in the Declarations section should be:

‚Ä¢ You need a new %token declaration for the ROTATION token. It has the same structure as the line for the NUMBER token, except that ‚Äúnum‚Äù is replaced by ‚Äústr‚Äù (since ROTATION represents a string, being a name for a function, whereas NUMBER represents a number).

‚Ä¢ For symbols that represent a binary (i.e., two-argument) arithmetic operation, it is worth including them in an appropriate %left statement. Each of these statements makes the parser treat these operations as left-associative, which helps it determine the order in which to do the operations and removes some sources of possible ambiguity. When using %left, operations having the same precedence are listed on the same line with spaces between them. So for + and ‚Äì you can use the following statement:

%left ‚Äô-‚Äô ‚Äô+‚Äô

A similar line can be used for multiplication and division. For operations whose %left statements are on different lines, the operations with higher precedence are those with higher line numbers (i.e., later in the file). Right-associative operations can be handled similarly with a %right statement. Treat exponentiation as having higher precedence than multiplication and division.

‚Ä¢ For every nonterminal symbol, you need a %type line that declares its type, i.e., the type of value that is returned when an expression generated from this nonterminal is evaluated. For example,

%type &lt;qtn&gt; start here

Here, ‚Äúqtn‚Äù is the type name we are using for quaternions. The various type names can be seen in the %union statement a little earlier in the file. But you do not need to know how that works in order to do this task.

‚Ä¢ You should still use start as your Start symbol. If you use another name instead, you will need to modify the %start line too.

Sample output: $./a.out

Rotation(120,2i+2j+2k) * i / Rotation(120,2i+2j+2k)

0.000000 + 0.000000 i + 1.000000 j + 0.000000 k

Control-D

Now refer to the explanation of quaternions and 3D rotations, page 14.

Convert your eight-digit student ID number into an angle and direction as follows. Let

d1d2d3d4d5d6d7d8

be the digits of your student ID number. Divide this into six single-digit numbers followed by one two-digit number: d1, d2, d3, d4, d5, d6, d7d8. The point to be rotated is (d1,d2,d3), which can be represented by the pure quaternion d1i + d2j + d3k. The axis of rotation is the line whose direction is given by d4i + d5j + d6k. (If this is the zero vector, then use (d1+d4)i+d5j+d6k instead.) Then work out the sum of the first digit d1 and the two-digit number d7d8, and use it for your angle of rotation, Œ∏‚ó¶.

For example, if your ID number is 12345678, then your point to be rotated is (1,2,3), your axis of rotation is 4i + 5j + 6k, and your angle is 78 + 1 = 79‚ó¶.

(a) Write down the quaternion expression in QUAT that represents the calculation required to rotate the pointR (d1,d2,d3) by Œ∏ degrees clockwise around the axis whose direction is given by d4i + d5j + d6k.

(Your expression must use the actual numbers derived from your student ID number as specified, not the algebraic quantities used above.)

Append the string ‚ÄúHamilton‚Äù, out of respect for the person who invented quaternions. (b) Run your parser on your expression from (a), and report the result of evaluating it.

The answers to (a) and (b) should be copied into a single line each in the file prob6.txt.

Turing machines

Now refer to the description of walks on page 15. Let CW be the language of closed walks using alphabet {N,S,E,W}.

Build, in Tuatara, a decider for CW and save it as a file prob7.tm.

There is no restriction on the contents of the output tape at the end of the computation.

Context-Free Languages

Prove or disprove: The language CW is context-free.

Please mention the Cocke-Younger-Kasami algorithm (but there is no need to demonstrate it). Your submission can be typed or hand-written, but it must be in PDF format and saved as a file prob8.pdf.

Lex, Yacc and the PLUS-TIMES-POWER language

In this part of the Assignment, you will use the lexical analyser generator lex, initially by itself, and then with the parser generator yacc .

Some useful references on Lex and Yacc:

‚Ä¢ T. Niemann, Lex &amp; Yacc Tutorial, http://epaperpress.com/lexandyacc/

‚Ä¢ Doug Brown, John Levine, and Tony Mason, lex and yacc (2nd edn.), O‚ÄôReilly, 2012.

‚Ä¢ the lex and yacc manpages

We will illustrate the use of these programs with a language PLUS-TIMES-POWER based on simple arithmetic expressions involving nonnegative integers, using just addition, multiplication and powers. Then you will use lex and yacc on a language QUAT of expressions based on quaternions, which we describe later.

PLUS-TIMES-POWER

The language PLUS-TIMES-POWER consists of expressions involving addition, multiplication and powers of nonnegative integers, without any parentheses (except for those required by the function Power). Example expressions include:

5 + 8, 8 + 5, 3 + 5 ‚àó 2, 13 + 8 ‚àó 4 + Power(2,Power(3,2)), Power(1,3) + Power(5,3) + Power(3,3), Power(999,0), 0 + 99 ‚àó 0 + 1, 2014, 10 ‚àó 14 + 74 + 10 ‚àó 13 ‚àó 73, 2 ‚àó 3 ‚àó 5 ‚àó 7 ‚àó 11 ‚àó 13 ‚àó 17 ‚àó 19.

In these expressions, integers are written in unsigned decimal, with no leading zeros or decimal point (so 2014, 86, 10, 7, and 0 are ok, but +2014, ‚àí2014, 86.0, A, 007, and 00 are not).

For lexical analysis, we treat every nonnegative integer as a lexeme for the token NUMBER.

Lex

An input file to lex is, by convention, given a name ending in .l. Such a file has three parts:

‚Ä¢ definitions,

‚Ä¢ rules,

‚Ä¢ C code.

These are separated by double-percent, %%. Comments begin with /* and end with */. Any comments are ignored when lex is run on the file.

You will find an input file, plus-times-power.l, among the files for this Assignment. Study its structure now, identifying the three sections and noticing that various pieces of code have been commented out. Those pieces of code are not needed yet, but some will be needed later.

We focus mainly on the Rules section, in the middle of the file. It consists of a series of statements of the form

pattern { action }

where the pattern is a regular expression and the action consists of instructions, written in C, specifying what to do with text that matches the pattern. In our file, each pattern represents a set of possible lexemes which we wish to identify. These are:

‚Ä¢ a decimal representation of a nonnegative integer, represented as described above; ‚Äì This is taken to be an instance of the token NUMBER (i.e., a lexeme for that token).

‚Ä¢ the specific string Power, which is taken to be an instance of the token POWER.

‚Ä¢ certain specific characters: +, *, (, ), and comma;

‚Ä¢ the newline character;

‚Ä¢ white space, being any sequence of spaces and tabs.

Note that all matching in lex is case-sensitive.

Our action is, in most cases, to print a message saying what token and lexeme have been found. For white space, we take no action at all. A character that cannot be matched by any pattern yields an error message.

If you run lex on the file plus-times-power.l, then lex generates the C program lex.yy.c. This is the source code for the lexical analyser. You compile it using a C compiler such as cc.

For this assignment we use flex, a more modern variant of lex. We generate the lexical analyser as follows.

$flex plus-times-power.l

$cc lex.yy.c

By default, cc puts the executable program in a file usually called a.out but sometimes called a.exe. This can be executed in the usual way, by just entering ./a.out at the command line. If you prefer to give the executable program another name, such as plus-times-power-lex, then you can tell this to the compiler using the -o option: cc lex.yy.c -o plus-times-power-lex.

When you run the program, it will initially wait for you to input a line of text to analyse. Do so, pressing Return at the end of the line. Then the lexical analyser will print, to standard output, messages showing how it has analysed your input. The printing of these messages is done by the printf statements from the file plus-times-power.l. Note how it skips over white space, and only reports on the lexemes and tokens.

$./a.out

13+8 * 4 + Power(2,Power (3,2 ))

Token: NUMBER; Lexeme: 13

Token and Lexeme: +

Token: NUMBER; Lexeme: 8 Token and Lexeme: *

Token: NUMBER; Lexeme: 4

Token and Lexeme: +

Token: POWER; Lexeme: Power

Token and Lexeme: (

Token: NUMBER; Lexeme: 2

Token and Lexeme: ,

Token: POWER; Lexeme: Power

Token and Lexeme: (

Token: NUMBER; Lexeme: 3 Token and Lexeme: ,

Token: NUMBER; Lexeme: 2

Token and Lexeme: )

Token and Lexeme: )

Token and Lexeme: &lt;newline&gt;

Try running this program with some input expressions of your own. You can keep entering new expressions on new lines, and enter Control-D to stop when you are finished.

Yacc

We now turn to parsing, using yacc.

Consider the following grammar for PLUS-TIMES-POWER.

S ‚àí‚Üí E

E ‚àí‚Üí I

E ‚àí‚Üí POWER(E,E)

E ‚àí‚Üí E ‚àó E

E ‚àí‚Üí E + E

I ‚àí‚Üí NUMBER

In this grammar, the non-terminals are S, E and I. Treat NUMBER and POWER as just single tokens, and hence single terminal symbols in this grammar.

We now generate a parser for this grammar, which will also evaluate the expressions, with +,‚àó interpreted as the usual integer arithmetic operations and Power(‚Ä¶,‚Ä¶) interpreted as raising its first argument to the power of its second argument.

To generate this parser, you need two files, prob1.l (for lex) and plus-times-power.y (for yacc):

‚Ä¢ Change into your problem1 subdirectory and do the following steps in that directory.

‚Ä¢ Copy plus-times-power.l to a new file prob1.l, and then modify prob1.l as follows:

‚Äì in the Declarations section, uncomment the statement #include ‚Äúy.tab.h‚Äù; ‚Äì in the Rules section, in each action:

‚àó uncomment the statements of the form

¬∑ yylval.str = ‚Ä¶;

¬∑ yylval.num = ‚Ä¶; ¬∑ return TOKENNAME; ¬∑ return *yytext; ¬∑ yyerror‚Ä¶

‚Äì in the C code section, comment out the function main(), which in this case occupies four lines at the end of the file.

‚Ä¢ plus-times-power.y, the input file for yacc, is provided for you. You don‚Äôt need to modify this yet.

An input file for yacc is, by convention, given a name ending in .y, and has three parts, very loosely analogous to the three parts of a lex file but very different in their details and functionality:

‚Ä¢ Declarations,

‚Ä¢ Rules,

‚Ä¢ Programs.

These are separated by double-percent, %%. Comments begin with /* and end with */.

Peruse the provided file plus-times-power.y, identify its main components, and pay particular attention to the following, since you will need to modify some of them later.

‚Ä¢ in the Declarations section:

‚Äì lines like

int printQuaternion(Quaternion);

Quaternion newQuaternion(double, double, double, double);

‚Ä¶

Quaternion rotation(double, Quaternion); which are declarations of functions (but they are defined later, in the Programs section); ‚Äì declarations of the tokens to be used:

%token &lt;num&gt; NUMBER

%token &lt;iValue&gt; WHOLENUMBER

%token &lt;str&gt; POWER

‚Äì some specifications that certain operations are left-associative (which helps determine the order in which operations are applied and can help resolve conflicts and ambiguities):

%left ‚Äô+‚Äô

%left ‚Äô*‚Äô

‚Äì declarations of the nonterminal symbols to be used (which don‚Äôt need to start with an upper-case letter):

%type &lt;iValue&gt; start

%type &lt;iValue&gt; line

%type &lt;iValue&gt; expr

%type &lt;iValue&gt; int

‚Äì nomination of which nonterminal is the Start symbol:

%start start

After constructing the new lex file prob1.l as above, the parser can be generated by:

$yacc -d plus-times-power.y

$flex prob1.l

$cc lex.yy.c y.tab.c -lm

The executable program, which is now a parser for PLUS-TIMES-POWER, is again named a.out by default, and will replace any other program of that name that happened to be sitting in the same directory.

$./a.out

13+8 * 4 + Power(2,Power (3,2 ))

557

13+8*4+Power(2,Power(3,2))

557

Power(1,3)+Power(5,3)+Power(3,3)

153

1+2+3+4+5+6+7+8+9+10

55

10*9*8*7*6*5*4*3*2*1

3628800

Power(999,0)

1

Control-D

Run it with some input expressions of your own. You can keep entering new expressions on new lines, as above, and enter Control-D to stop when you are finished.

Quaternions and the language QUAT

Introduction

The quaternions are a system of four-dimensional numbers that are used in computer graphics to describe rotations in three-dimensional space, beginning with Tomb Raider in 1996 [1]. They were discovered by William Rowan Hamilton in Dublin in 1843. Every quaternion has the form

w + xi + yj + zk,

where w,x,y,z ‚àà R and i,j,k are special quantities, called quaternion units, satisfying

i2 = ‚àí1,

j2 = ‚àí1,

k2 = ‚àí1,

ijk = ‚àí1.

Other properties that follow from these equations include:

ij = k, ji = ‚àík,

jk = i, kj = ‚àíi,

ki = j, ik = ‚àíj.

These properties can be used to compute any sum or product of quaternions, since the usual associative and distributive laws still apply. Note, though, that multiplication of quaternions is not commutative: the order of multiplication affects the outcome, in general.

The set of quaternions is denoted by H, just as the sets of real and complex numbers are denoted by R and C respectively.

In this assignment, you will construct a quaternionic calculator for parsing and evaluating arithmetic expressions involving quaternions.

Quaternions: representation

42.00 are all valid, but 042, 0042, 042.0, etc are invalid.

Quaternion operations

We allow all the four arithmetic operations on quaternions, denoted by the usual symbols, +, -, *, / ‚Äî and grouping by parentheses, (‚Ä¶). We also allow:

‚Ä¢ exponentiation, denoted by ^, with an integer exponent. So, e.g., (1-2i+3j-4k)^3 represents (1‚àí2i+3j‚àí4k)3, the cube of 1‚àí2i+3j‚àí4k, while (1-2i+3j-4k)^-3 is (1‚àí2i+3j‚àí4k)‚àí3.

‚Ä¢ absolute value, denoted by |¬∑¬∑¬∑| (just as for real and complex numbers). We treat |q| as giving a quaternion with zero imaginary part. The real part of |q| is nonnegative and gives the length of the quaternion q.

‚Ä¢ the special operation Rotation(‚Ä¶,‚Ä¶), written as a function, which creates a quaternion that represents a 3D rotation. The Rotation function takes two arguments, the first being a number, and the second being any quaternion expression.

The functions to do these operations have all been written for you and provided in the file plus-times-power.y. You only need to modify a copy of that file, using the guidance below, to build your calculator.

Quaternion expressions

These operations can be combined in the same way in which they are combined when used for ‚Äúnormal‚Äù numbers (real, complex, etc.) to make expressions. Any valid expression can be given as the second argument of Rotation(‚Ä¶,‚Ä¶), to give another valid expression, and expressions using Rotation(‚Ä¶,‚Ä¶) can be combined using arithmetic operations.

We formalise the concept of a quaternion expression with the following inductive definition:

1. Each of i, j, k is a quaternion expression.

2. If r is any nonnegative integer or any nonnegative real number, then each of r, ri, rj, rk is a quaternion expression.

3. If p and q are quaternion expressions, then so are: (q), |q|, ‚àíq, p+q, p‚àíq, p‚àóq, p/q.

4. If q is a quaternion expression and n is a nonnegative integer, then each of the following is a quaternion expression: qÀÜn, qÀÜ-n.

5. If r is a nonnegative integer or a nonnegative real number and q is a quaternion expression, then the following is a quaternion expression: Rotation(r,q)

Notes:

‚Ä¢ Negative numbers can be represented by negating positive numbers.

‚Ä¢ We allow juxtaposition of any number r with any of i,j,k to form the simple expressions ri, rj and rk. This enables the succinct quaternion notation ¬±w ¬± xi ¬± yj ¬± zk. However, apart from that, multiplication in our quaternion expressions is always denoted by a star, ‚àó.

The language QUAT

expression evaluates to

(0.5 ‚àí 1.618j ‚àí 32i ‚àó j ‚àí k/(3.5 + i ‚àó j))/(i/j ‚àí k ‚àó 48) 0.658452 + ‚àí0.033020i + 0.000000j + 0.008664k

3i ‚àó j ‚àó k ‚àí3

‚àí1 + 2i ‚àí 0.30 ‚àó j + 4. ‚àó k ‚àí1 + 2i ‚àí 0.3j + 4.0k

0 0

(‚àí0.5 + 0.866j)ÀÜ‚àí3 1.000066 + ‚àí0.000038j

|j ‚àí 1.732k| 2

Let QUAT be the language of valid quaternion expressions in which all numbers are finite decimal representations. Here are some examples of valid quaternion expressions (i.e., members of QUAT):

Rotation(120,2i + 2j + 2k) ‚àó i/Rotation(120,2i + 2j + 2k) j

Some examples of invalid quaternion expressions (i.e., not members of QUAT):

expression comment

3i ‚àó j k The product of j and k should use ‚àó instead of juxtaposition.

‚àí1 + 2i ‚àí .3 ‚àó j + 4.0 ‚àó k Need at least one digit before decimal point.

Power(‚àí0.5 + 0.866j,3) Power is not valid in QUAT; we only use it in PLUS-TIMES-POWER.

We treat QUAT as a language over the fifteen-symbol alphabet {i, j, k, +, -, *, /, ^, |, (, ), NUMBER, WHOLENUMBER, ROTATION, , }. Here,

‚Ä¢ NUMBER is a token representing any finite decimal representation of a nonnegative real number,

‚Ä¢ WHOLENUMBER is a token representing any nonnegative integer,

‚Ä¢ ROTATION is a token representing the name of the Rotation function.

Quaternions and 3D rotations

We can use quaternions to rotate a point around an axis in 3D space. Throughout, we assume the axis goes through the origin.

Points in 3D space are represented as pure quaternions, which means quaternions of the form xi + yj + zk, so they have no real part w. This is just another way of representing threedimensional space using standard co-ordinate axes. In effect, the three basic quaternion units i,j,k are unit vectors along the x,y,z-axes, respectively, and correspond to points (1,0,0),(0,1,0),(0,0,1) respectively.

A rotation is specified by giving its axis as a unit vector, i.e., a pure quaternion of length 1, and its angle as a number. If the unit-length pure quaternion ÀÜq gives the direction of the axis of rotation, and Œ∏ is the angle of rotation around that axis (clockwise, as viewed from the origin looking in the direction in which q points), then the quaternion Rotation(Œ∏,qÀÜ) that represents the rotation is given by

Rotation(Œ∏,qÀÜ) = cos(Œ∏/2) + sin(Œ∏/2) ¬∑ q.ÀÜ

More generally, if q is any nonzero quaternion, then Rotation(Œ∏,q) scales q to give the unit-length quaternion ÀÜq that points in the same direction, and gives

Rotation(Œ∏,q) = cos(Œ∏/2) + sin(Œ∏/2) ¬∑ q.ÀÜ

It is this quaternion that is returned by the function rotation (provided in plus-times-power.y) and by the Rotation operation in quaternion expressions.

In order to apply the rotation to a point p, we first represent p as a pure quaternion, p = xi + yj + zk, and then form the expression

Rotation(Œ∏,q) ‚àó p/Rotation(Œ∏,q).

So, our earlier calculation that Rotation(120,2i+2j+2k) * i / Rotation(120,2i+2j+2k) evaluates to j expresses the fact that, if your axis is the line with direction i + j + k, then rotating the point (1,0,0) by 120‚ó¶ clockwise around this axis gives the point (0,1,0).

In this assignment, we restrict to angles Œ∏ ‚â• 0. We lose no generality by doing this, since any rotation is equivalent to rotation about the same axis by some angle Œ∏ in the range 0‚ó¶ ‚â§ Œ∏ &lt; 360‚ó¶.

References

[1] Nick Bobic, Rotating objects using quaternions, Game Developer, Feb. 1998. Available at: https://www.gamasutra.com/view/feature/3278/rotating_objects_using_quaternions.

php?print=1

[2] Daniel Chan, Quaternions are turning tomb raiders on their heads, Parabola 40 (no. 2) (2004).

Available at: https://www.parabola.unsw.edu.au/files/articles/2000-2009/volume-402004/issue-2/vol40_no2_2.pdf or https://web.maths.unsw.edu.au/~danielch/talent/ quat1.pdf

Walks

Imagine you are standing at the origin on an infinite x,y-plane. A walk is a sequence of steps of one unit each in which each step can be in any one of the four directions parallel to the coordinate axes. A walk is represented as a string over the alphabet {N,S,E,W}, in which the letters represent the possible steps according to the following table.

letter stands for: represents a step of:

N North one unit in the positive y direction

S South one unit in the negative y direction

E East one unit in the positive x direction

W West one unit in the negative x direction

A walk is closed if it ends where it starts, i.e., at the origin.

Some examples of walks, relating the strings that represent them to the routes they take, are:

string journey lines used comments

in diagram

EENWSSSEWSWW (0,0) ‚Üí (1,0) ‚Üí (2,0) ‚Üí (2,‚àí1) ‚Üí

(1,‚àí1) ‚Üí (1,0) ‚Üí (1,1) ‚Üí (1,2) ‚Üí (2,2) ‚Üí (1,2) ‚Üí (1,3) ‚Üí (0,3) ‚Üí

(‚àí1,3) red, straight not closed

NWWWNESESE (0,0) ‚Üí (0,1) ‚Üí (‚àí1,1) ‚Üí (‚àí2,1) ‚Üí (‚àí3,1) ‚Üí (‚àí3,2) ‚Üí (‚àí2,2) ‚Üí

(‚àí2,1) ‚Üí (‚àí1,1) ‚Üí (‚àí1,0) ‚Üí (0,0) green, zigzag closed

SWWSWSEEN (0,0) ‚Üí (0,‚àí1) ‚Üí (‚àí1,‚àí1) ‚Üí

(‚àí2,‚àí1) ‚Üí (‚àí2,‚àí2) ‚Üí (‚àí3,‚àí2) ‚Üí

(‚àí3,‚àí3) ‚Üí (‚àí2,‚àí3) ‚Üí (‚àí1,‚àí3) ‚Üí

(‚àí1,‚àí2) blue, wavy not closed

Œµ (0,0) yellow dot

y closed

These walks are illustrated in the diagram on the right.
